(function(){var P$=Clazz.newPackage("org.jmol.export"),p$1={},I$=[[0,'java.util.Hashtable','javajs.util.P3','org.jmol.export.UseTable','org.jmol.export.___Exporter','org.jmol.viewer.Viewer','javajs.util.PT','javajs.util.A4','javajs.util.Quat','javajs.util.AU','org.jmol.util.Geodesic','javajs.util.Measure','javajs.util.Lst']],$I$=function(i,n,m){return m?$I$(i)[n].apply(null,m):((i=(I$[i]||(I$[i]=Clazz.load(I$[0][i])))),!n&&i.$load$&&Clazz.load(i,2),i)};
/*c*/var C$=Clazz.newClass(P$, "_VrmlExporter", null, 'org.jmol.export.__CartesianExporter');

C$.$clinit$=2;

Clazz.newMeth(C$, '$init$', function () {
this.htSpheresRendered=Clazz.new_($I$(1,1));
this.tempQ1=Clazz.new_($I$(2,1));
this.tempQ2=Clazz.new_($I$(2,1));
this.tempQ3=Clazz.new_($I$(2,1));
},1);

C$.$fields$=[['F',['fontSize'],'S',['fontFace','fontStyle','fontChild'],'O',['useTable','org.jmol.export.UseTable','htSpheresRendered','java.util.Map','plateVertices','javajs.util.T3[]','plateIndices','int[][]','plateColixes','short[]','tempQ1','javajs.util.P3','+tempQ2','+tempQ3','oneFace','int[][]','threeVertices','javajs.util.P3[]']]]

Clazz.newMeth(C$, 'c$', function () {
Clazz.super_(C$, this);
this.useTable=Clazz.new_($I$(3,1).c$$S,["USE "]);
this.commentChar="# ";
this.canCapCylinders=true;
this.solidOnly=true;
}, 1);

Clazz.newMeth(C$, 'output$javajs_util_T3', function (pt) {
this.output$S($I$(4).round$javajs_util_T3(pt));
});

Clazz.newMeth(C$, 'outputHeader$', function () {
this.output$S("#VRML V2.0 utf8 Generated by Jmol " + $I$(5).getJmolVersion$() + "\n" );
this.output$S("WorldInfo { \n");
this.output$S(" title " + $I$(6).esc$S(this.vwr.ms.modelSetName) + "\n" );
this.output$S(" info [ \"Generated by Jmol " + $I$(5).getJmolVersion$() + " \", \n" );
this.output$S("  \"http://www.jmol.org \", \n");
this.output$S("  \"Creation date: " + this.getExportDate$() + " \" ]\n" );
this.output$S("} \n");
this.output$S("NavigationInfo { type \"EXAMINE\" } \n");
this.output$S("Background { skyColor [" + this.rgbFractionalFromColix$H(this.backgroundColix) + "] } \n" );
var angle=this.getViewpoint$();
this.output$S("Viewpoint{fieldOfView " + new Float(angle).toString());
this.output$S(" position ");
this.cameraPosition.scale$F(this.exportScale);
this.output$javajs_util_T3(this.cameraPosition);
this.output$S(" orientation ");
this.output$javajs_util_T3(this.tempP1);
this.output$S(" " + new Float(-this.viewpoint.angle).toString());
this.output$S("\n jump TRUE description \"v1\"\n}\n\n");
this.output$S(this.getJmolPerspective$());
this.outputInitialTransform$();
this.output$S("\n");
});

Clazz.newMeth(C$, 'outputInitialTransform$', function () {
this.pushMatrix$();
this.outputAttr$S$F$F$F("scale", this.exportScale, this.exportScale, this.exportScale);
this.outputCloseTag$();
this.outputChildStart$();
this.pushMatrix$();
this.tempP1.setT$javajs_util_T3(this.center);
this.tempP1.scale$F(-1);
this.outputAttrPt$S$javajs_util_T3("translation", this.tempP1);
this.outputCloseTag$();
this.outputChildStart$();
});

Clazz.newMeth(C$, 'getViewpoint$', function () {
this.viewpoint.setM$javajs_util_M3(this.vwr.tm.matrixRotate);
this.tempP1.set$F$F$F(this.viewpoint.x, this.viewpoint.y, (this.viewpoint.angle == 0  ? 1 : this.viewpoint.z));
return (this.apertureAngle * 3.141592653589793 / 180);
});

Clazz.newMeth(C$, 'outputFooter$', function () {
this.useTable=null;
this.output$S("\n]}\n");
this.output$S("]}");
});

Clazz.newMeth(C$, 'outputAppearance$H$Z', function (colix, isText) {
var def=this.getDef$S((isText ? "T" : "") + colix);
this.output$S("appearance ");
if (def.charAt$I(0) == "_") {
var color=this.rgbFractionalFromColix$H(colix);
this.output$S(" DEF " + def + " Appearance{material Material{diffuseColor " );
if (isText) this.output$S(" 0 0 0 specularColor 0 0 0 ambientIntensity 0.0 shininess 0.0 emissiveColor " + color + " }}" );
 else this.output$S(color + " transparency " + $I$(4).translucencyFractionalFromColix$H(colix) + "}}" );
return;
}this.output$S(def);
});

Clazz.newMeth(C$, 'pushMatrix$', function () {
this.output$S("Transform{");
});

Clazz.newMeth(C$, 'popMatrix$', function () {
this.output$S("}\n");
});

Clazz.newMeth(C$, 'outputAttrPt$S$javajs_util_T3', function (attr, pt) {
this.output$S(" " + attr + " " + new Float(pt.x).toString() + " " + new Float(pt.y).toString() + " " + new Float(pt.z).toString() );
});

Clazz.newMeth(C$, 'outputAttr$S$F$F$F', function (attr, x, y, z) {
this.output$S(" " + attr + " " + $I$(4).round$D(x) + " " + $I$(4).round$D(y) + " " + $I$(4).round$D(z) );
});

Clazz.newMeth(C$, 'outputRotation$javajs_util_A4', function (a) {
this.output$S(" rotation " + new Float(a.x).toString() + " " + new Float(a.y).toString() + " " + new Float(a.z).toString() + " " + new Float(a.angle).toString() );
});

Clazz.newMeth(C$, 'outputTransRot$javajs_util_P3$javajs_util_P3$I$I$I', function (pt1, pt2, x, y, z) {
this.tempV1.ave$javajs_util_T3$javajs_util_T3(pt2, pt1);
this.outputAttrPt$S$javajs_util_T3("translation", this.tempV1);
this.tempV1.sub$javajs_util_T3(pt1);
this.tempV1.normalize$();
this.tempV2.set$F$F$F(x, y, z);
this.tempV2.add$javajs_util_T3(this.tempV1);
this.outputRotation$javajs_util_A4($I$(7).newVA$javajs_util_V3$F(this.tempV2, 3.1415927));
});

Clazz.newMeth(C$, 'outputQuaternionFrame$javajs_util_P3$javajs_util_P3$javajs_util_P3$javajs_util_P3$F$F$F', function (ptCenter, ptX, ptY, ptZ, xScale, yScale, zScale) {
this.tempQ1.setT$javajs_util_T3(ptX);
this.tempQ2.setT$javajs_util_T3(ptY);
var a=$I$(8).getQuaternionFrame$javajs_util_P3$javajs_util_T3$javajs_util_T3(ptCenter, this.tempQ1, this.tempQ2).toAxisAngle4f$();
if (!Float.isNaN$F(a.x)) {
this.tempQ1.set$F$F$F(a.x, a.y, a.z);
this.outputRotation$javajs_util_A4(a);
}var sx=(ptX.distance$javajs_util_T3(ptCenter) * xScale);
var sy=(ptY.distance$javajs_util_T3(ptCenter) * yScale);
var sz=(ptZ.distance$javajs_util_T3(ptCenter) * zScale);
this.outputAttr$S$F$F$F("scale", sx, sy, sz);
});

Clazz.newMeth(C$, 'outputChildShapeStart$', function () {
this.outputChildStart$();
this.outputShapeStart$();
});

Clazz.newMeth(C$, 'outputChildStart$', function () {
this.output$S(" children[");
});

Clazz.newMeth(C$, 'outputShapeStart$', function () {
this.output$S(" Shape{geometry ");
});

Clazz.newMeth(C$, 'outputDefChildFaceSet$S', function (child) {
if (child != null ) this.output$S("DEF " + child + " " );
this.outputFaceSetStart$();
});

Clazz.newMeth(C$, 'outputFaceSetStart$', function () {
this.output$S("IndexedFaceSet {");
});

Clazz.newMeth(C$, 'outputFaceSetClose$', function () {
this.output$S("}\n");
});

Clazz.newMeth(C$, 'outputUseChildClose$S', function (child) {
this.output$S(child);
});

Clazz.newMeth(C$, 'outputChildShapeClose$', function () {
this.outputShapeClose$();
this.outputChildClose$();
});

Clazz.newMeth(C$, 'outputChildClose$', function () {
this.output$S("]");
});

Clazz.newMeth(C$, 'outputShapeClose$', function () {
this.output$S("}");
});

Clazz.newMeth(C$, 'outputCloseTag$', function () {
});

Clazz.newMeth(C$, 'outputCircle$javajs_util_P3$javajs_util_P3$F$H$Z', function (pt1, pt2, radius, colix, doFill) {
if (doFill) {
this.pushMatrix$();
this.tempV1.ave$javajs_util_T3$javajs_util_T3(pt1, pt2);
this.outputAttr$S$F$F$F("translation", this.tempV1.x, this.tempV1.y, this.tempV1.z);
this.output$S(" children [ Billboard{axisOfRotation 0 0 0 children [ Transform{rotation 1 0 0 1.5708");
var height=(pt1.distance$javajs_util_T3(pt2));
this.outputAttr$S$F$F$F("scale", radius, height, radius);
this.outputCylinderChildScaled$H$B(colix, 2);
this.output$S("}] }]\n");
this.popMatrix$();
return;
}var child=this.getDef$S("C" + colix + "_" + new Float(radius).toString() );
this.pushMatrix$();
this.outputTransRot$javajs_util_P3$javajs_util_P3$I$I$I(pt1, pt2, 0, 0, 1);
this.outputAttr$S$F$F$F("scale", radius, radius, radius);
this.output$S(" children [");
if (child.charAt$I(0) == "_") {
this.output$S("DEF " + child);
this.output$S(" Billboard{axisOfRotation 0 0 0 children [ Transform{children[");
this.output$S(" Shape{");
this.output$S("geometry Extrusion{beginCap FALSE convex FALSE endCap FALSE creaseAngle 1.57");
this.output$S(" crossSection [");
var rpd=0.017453292;
var scale=0.02 / radius;
for (var i=0; i <= 360; i+=10) {
this.output$S($I$(4,"round$D",[Math.cos(i * rpd) * scale]) + " ");
this.output$S($I$(4,"round$D",[Math.sin(i * rpd) * scale]) + " ");
}
this.output$S("] spine [");
for (var i=0; i <= 360; i+=10) {
this.output$S($I$(4,"round$D",[Math.cos(i * rpd)]) + " ");
this.output$S($I$(4,"round$D",[Math.sin(i * rpd)]) + " 0 ");
}
this.output$S("]");
this.output$S("}");
this.outputAppearance$H$Z(colix, false);
this.output$S("}");
this.output$S("]} ]}");
} else {
this.output$S(child);
}this.output$S("]");
this.popMatrix$();
});

Clazz.newMeth(C$, 'outputCone$javajs_util_P3$javajs_util_P3$F$H', function (ptBase, ptTip, radius, colix) {
var height=(ptBase.distance$javajs_util_T3(ptTip));
this.pushMatrix$();
this.outputTransRot$javajs_util_P3$javajs_util_P3$I$I$I(ptBase, ptTip, 0, 1, 0);
this.outputAttr$S$F$F$F("scale", radius, height, radius);
this.outputCloseTag$();
this.outputChildShapeStart$();
var child=this.getDef$S("c");
if (child.charAt$I(0) == "_") {
this.outputDefChildFaceSet$S(child);
p$1.outputConeGeometry$Z.apply(this, [true]);
this.outputFaceSetClose$();
} else {
this.outputUseChildClose$S(child);
}this.outputAppearance$H$Z(colix, false);
this.outputChildShapeClose$();
this.popMatrix$();
});

Clazz.newMeth(C$, 'outputConeGeometry$Z', function (addBase) {
var ndeg=10;
var n=(360/ndeg|0);
var vertexCount=n + (addBase ? 2 : 1);
var faces=$I$(9,"newInt2$I",[n * (addBase ? 2 : 1)]);
for (var i=0, fpt=0; i < n; i++) {
faces[fpt++]=Clazz.array(Integer.TYPE, -1, [i, (i + n - 1) % n, n]);
if (addBase) faces[fpt++]=Clazz.array(Integer.TYPE, -1, [i, (i + 1) % n, n + 1]);
}
var vertexes=Clazz.array($I$(2), [vertexCount]);
for (var i=0; i < n; i++) {
var x=(Math.cos(i * ndeg / 180.0 * 3.141592653589793));
var y=(Math.sin(i * ndeg / 180.0 * 3.141592653589793));
vertexes[i]=$I$(2).new3$F$F$F(x, -0.5, y);
}
vertexes[n++]=$I$(2).new3$F$F$F(0, 0.5, 0);
if (addBase) vertexes[n++]=$I$(2).new3$F$F$F(0, -0.5, 0);
this.outputGeometry$javajs_util_T3A$javajs_util_T3A$HA$IAA$HA$I$I$javajs_util_BS$I$javajs_util_Lst$java_util_Map$javajs_util_P3(vertexes, null, null, faces, null, vertexCount, faces.length, null, 3, null, null, null);
}, p$1);

Clazz.newMeth(C$, 'outputCylinder$javajs_util_P3$javajs_util_P3$javajs_util_P3$H$B$F$javajs_util_P3$javajs_util_P3$Z', function (ptCenter, pt1, pt2, colix, endcaps, radius, ptX, ptY, checkRadius) {
var height=(pt1.distance$javajs_util_T3(pt2));
if (radius < 0.01  || height == 0  ) return false;
this.pushMatrix$();
if (ptX == null ) {
this.outputTransRot$javajs_util_P3$javajs_util_P3$I$I$I(pt1, pt2, 0, 1, 0);
this.outputAttr$S$F$F$F("scale", radius, height, radius);
} else {
this.outputAttrPt$S$javajs_util_T3("translation", ptCenter);
this.outputQuaternionFrame$javajs_util_P3$javajs_util_P3$javajs_util_P3$javajs_util_P3$F$F$F(ptCenter, ptY, pt1, ptX, 2, 2, 2);
pt1.set$F$F$F(0, 0, -0.5);
pt2.set$F$F$F(0, 0, 0.5);
}this.outputCloseTag$();
this.outputCylinderChildScaled$H$B(colix, endcaps);
this.popMatrix$();
if (radius > 0.1 ) switch (endcaps) {
case 3:
this.outputSphere$javajs_util_P3$F$H$Z(pt1, radius * 1.01, colix, checkRadius);
case 5:
case 4:
this.outputSphere$javajs_util_P3$F$H$Z(pt2, radius * 1.01, colix, checkRadius);
break;
case 2:
break;
}
return true;
});

Clazz.newMeth(C$, 'outputCylinderChildScaled$H$B', function (colix, endcaps) {
this.outputChildShapeStart$();
var child=this.getDef$S("C" + "_" + endcaps );
if (child.charAt$I(0) == "_") {
this.outputDefChildFaceSet$S(child);
p$1.outputCylinderGeometry$I.apply(this, [endcaps]);
this.outputFaceSetClose$();
} else {
this.outputUseChildClose$S(child);
}this.outputAppearance$H$Z(colix, false);
this.outputChildShapeClose$();
});

Clazz.newMeth(C$, 'outputCylinderGeometry$I', function (endcaps) {
var ndeg=10;
var n=(360/ndeg|0);
var vertexCount=n * 2;
var addEndcaps=false;
switch (endcaps) {
case 3:
case 5:
case 4:
case 2:
vertexCount+=2;
addEndcaps=true;
break;
}
var faces=$I$(9,"newInt2$I",[n * (addEndcaps ? 4 : 2)]);
for (var i=0, fpt=0; i < n; i++) {
faces[fpt++]=Clazz.array(Integer.TYPE, -1, [i, (i + 1) % n, i + n]);
faces[fpt++]=Clazz.array(Integer.TYPE, -1, [(i + 1) % n, (i + 1) % n + n, i + n]);
if (addEndcaps) {
faces[fpt++]=Clazz.array(Integer.TYPE, -1, [i, (i + n - 1) % n, vertexCount - 2]);
faces[fpt++]=Clazz.array(Integer.TYPE, -1, [i + n, (i + n + 1 ) % n + n, vertexCount - 1]);
}}
var vertexes=Clazz.array($I$(2), [vertexCount]);
for (var i=0; i < n; i++) {
var x=(Math.cos(i * ndeg / 180.0 * 3.141592653589793));
var y=(Math.sin(i * ndeg / 180.0 * 3.141592653589793));
vertexes[i]=$I$(2).new3$F$F$F(x, 0.5, y);
}
for (var i=0; i < n; i++) {
var x=(Math.cos((i + 0.5) * ndeg / 180 * 3.141592653589793));
var y=(Math.sin((i + 0.5) * ndeg / 180 * 3.141592653589793));
vertexes[i + n]=$I$(2).new3$F$F$F(x, -0.5, y);
}
if (addEndcaps) {
vertexes[vertexCount - 2]=$I$(2).new3$F$F$F(0, 0.5, 0);
vertexes[vertexCount - 1]=$I$(2).new3$F$F$F(0, -0.5, 0);
}this.outputGeometry$javajs_util_T3A$javajs_util_T3A$HA$IAA$HA$I$I$javajs_util_BS$I$javajs_util_Lst$java_util_Map$javajs_util_P3(vertexes, null, null, faces, null, vertexCount, faces.length, null, 3, null, null, null);
}, p$1);

Clazz.newMeth(C$, 'outputSphere$javajs_util_P3$F$H$Z', function (ptCenter, radius, colix, checkRadius) {
var check=$I$(4).round$javajs_util_T3(ptCenter) + (checkRadius ? " " + ((radius * 100)|0) : "");
if (this.htSpheresRendered.get$O(check) != null ) return;
this.htSpheresRendered.put$O$O(check, Boolean.TRUE);
p$1.outputSphereChildScaled$javajs_util_P3$F$javajs_util_P3A$H.apply(this, [ptCenter, radius, null, colix]);
});

Clazz.newMeth(C$, 'outputEllipsoid$javajs_util_P3$javajs_util_P3A$H', function (ptCenter, points, colix) {
p$1.outputSphereChildScaled$javajs_util_P3$F$javajs_util_P3A$H.apply(this, [ptCenter, 1.0, points, colix]);
});

Clazz.newMeth(C$, 'outputSphereChildScaled$javajs_util_P3$F$javajs_util_P3A$H', function (ptCenter, radius, points, colix) {
this.pushMatrix$();
this.outputAttrPt$S$javajs_util_T3("translation", ptCenter);
if (points == null ) this.outputAttr$S$F$F$F("scale", radius, radius, radius);
 else this.outputQuaternionFrame$javajs_util_P3$javajs_util_P3$javajs_util_P3$javajs_util_P3$F$F$F(ptCenter, points[1], points[3], points[5], 1, 1, 1);
this.outputCloseTag$();
this.outputChildShapeStart$();
var child=this.getDef$S("S");
if (child.charAt$I(0) == "_") {
this.outputDefChildFaceSet$S(child);
p$1.outputSphereGeometry.apply(this, []);
this.outputFaceSetClose$();
} else {
this.outputUseChildClose$S(child);
}this.outputAppearance$H$Z(colix, false);
this.outputChildShapeClose$();
this.popMatrix$();
}, p$1);

Clazz.newMeth(C$, 'outputSphereGeometry', function () {
var vertices=$I$(10).getVertexVectors$();
var nVertices=162;
var faceList=$I$(10).getFaceVertexes$I(2);
var nFaces=(faceList.length/3|0);
var indices=Clazz.array(Integer.TYPE, [nFaces, 3]);
for (var i=0, p=0; i < nFaces; i++) for (var j=0; j < 3; j++) indices[i][j]=faceList[p++];


this.outputGeometry$javajs_util_T3A$javajs_util_T3A$HA$IAA$HA$I$I$javajs_util_BS$I$javajs_util_Lst$java_util_Map$javajs_util_P3(vertices, null, null, indices, null, nVertices, nFaces, null, 3, null, null, null);
}, p$1);

Clazz.newMeth(C$, 'outputSolidPlate$javajs_util_P3$javajs_util_P3$javajs_util_P3$H', function (tempP1, tempP2, tempP3, colix) {
if (this.plateVertices == null ) {
this.plateVertices=Clazz.array($I$(2), [6]);
for (var i=0; i < 6; i++) this.plateVertices[i]=Clazz.new_($I$(2,1));

this.plateIndices=Clazz.array(Integer.TYPE, -2, [Clazz.array(Integer.TYPE, -1, [0, 1, 2]), Clazz.array(Integer.TYPE, -1, [5, 4, 3]), Clazz.array(Integer.TYPE, -1, [0, 3, 1]), Clazz.array(Integer.TYPE, -1, [1, 3, 4]), Clazz.array(Integer.TYPE, -1, [1, 4, 2]), Clazz.array(Integer.TYPE, -1, [2, 4, 5]), Clazz.array(Integer.TYPE, -1, [2, 5, 0]), Clazz.array(Integer.TYPE, -1, [0, 5, 3])]);
}$I$(11).calcNormalizedNormal$javajs_util_T3$javajs_util_T3$javajs_util_T3$javajs_util_T3$javajs_util_T3(tempP1, tempP2, tempP3, this.tempV1, this.tempV2);
this.tempV1.scale$F(0.2);
this.plateVertices[0].setT$javajs_util_T3(tempP1);
this.plateVertices[1].setT$javajs_util_T3(tempP2);
this.plateVertices[2].setT$javajs_util_T3(tempP3);
for (var i=0; i < 3; i++) this.plateVertices[i].add$javajs_util_T3(this.tempV1);

this.tempV1.scale$F(-2);
for (var i=3; i < 6; i++) this.plateVertices[i].add2$javajs_util_T3$javajs_util_T3(this.plateVertices[i - 3], this.tempV1);

this.outputSurface$javajs_util_T3A$javajs_util_T3A$HA$IAA$HA$I$I$I$javajs_util_BS$I$H$javajs_util_Lst$java_util_Map$javajs_util_P3(this.plateVertices, null, null, this.plateIndices, this.plateColixes, 6, 8, 8, null, 3, colix, null, null, null);
});

Clazz.newMeth(C$, 'outputSurface$javajs_util_T3A$javajs_util_T3A$HA$IAA$HA$I$I$I$javajs_util_BS$I$H$javajs_util_Lst$java_util_Map$javajs_util_P3', function (vertices, normals, colixes, indices, polygonColixes, nVertices, nPolygons, nTriangles, bsPolygons, faceVertexMax, colix, colorList, htColixes, offset) {
this.outputShapeStart$();
this.outputDefChildFaceSet$S(null);
this.outputGeometry$javajs_util_T3A$javajs_util_T3A$HA$IAA$HA$I$I$javajs_util_BS$I$javajs_util_Lst$java_util_Map$javajs_util_P3(vertices, normals, colixes, indices, polygonColixes, nVertices, nPolygons, bsPolygons, faceVertexMax, colorList, htColixes, offset);
this.outputFaceSetClose$();
this.outputAppearance$H$Z(colix, false);
this.outputShapeClose$();
});

Clazz.newMeth(C$, 'outputGeometry$javajs_util_T3A$javajs_util_T3A$HA$IAA$HA$I$I$javajs_util_BS$I$javajs_util_Lst$java_util_Map$javajs_util_P3', function (vertices, normals, colixes, indices, polygonColixes, nVertices, nPolygons, bsPolygons, faceVertexMax, colorList, htColixes, offset) {
if (polygonColixes == null ) this.output$S("  creaseAngle 0.5  \n");
 else this.output$S(" colorPerVertex FALSE\n");
this.output$S("coord Coordinate {\npoint [\n");
this.outputVertices$javajs_util_T3A$I$javajs_util_T3(vertices, nVertices, offset);
this.output$S("   ]\n");
this.output$S("  }\n");
this.output$S("  coordIndex [\n");
var map=Clazz.array(Integer.TYPE, [nVertices]);
this.getCoordinateMap$javajs_util_T3A$IA$javajs_util_BS(vertices, map, null);
this.outputIndices$IAA$IA$I$javajs_util_BS$I(indices, map, nPolygons, bsPolygons, faceVertexMax);
this.output$S("  ]\n");
if (normals != null ) {
var vNormals=Clazz.new_($I$(12,1));
map=this.getNormalMap$javajs_util_T3A$I$javajs_util_BS$javajs_util_Lst(normals, nVertices, null, vNormals);
this.output$S("  solid FALSE\n  normalPerVertex TRUE\n   normal Normal {\n  vector [\n");
this.outputNormals$javajs_util_Lst(vNormals);
this.output$S("   ]\n");
this.output$S("  }\n");
this.output$S("  normalIndex [\n");
this.outputIndices$IAA$IA$I$javajs_util_BS$I(indices, map, nPolygons, bsPolygons, faceVertexMax);
this.output$S("  ]\n");
}map=null;
if (colorList != null ) {
this.output$S("  color Color { color [\n");
this.outputColors$javajs_util_Lst(colorList);
this.output$S("  ] } \n");
this.output$S("  colorIndex [\n");
this.outputColorIndices$IAA$I$javajs_util_BS$I$java_util_Map$HA$HA(indices, nPolygons, bsPolygons, faceVertexMax, htColixes, colixes, polygonColixes);
this.output$S("  ]\n");
}});

Clazz.newMeth(C$, 'outputFace$IA$IA$I', function (face, map, faceVertexMax) {
this.output$S(map[face[0]] + " " + map[face[1]] + " " + map[face[2]] + " -1\n" );
if (faceVertexMax == 4 && face.length == 4 ) this.output$S(map[face[0]] + " " + map[face[2]] + " " + map[face[3]] + " -1\n" );
});

Clazz.newMeth(C$, 'outputNormals$javajs_util_Lst', function (vNormals) {
var n=vNormals.size$();
for (var i=0; i < n; i++) {
this.output$S(vNormals.get$I(i));
}
});

Clazz.newMeth(C$, 'outputColors$javajs_util_Lst', function (colorList) {
var nColors=colorList.size$();
for (var i=0; i < nColors; i++) {
var color=this.rgbFractionalFromColix$H(colorList.get$I(i).shortValue$());
this.output$S(" ");
this.output$S(color);
this.output$S("\n");
}
});

Clazz.newMeth(C$, 'outputColorIndices$IAA$I$javajs_util_BS$I$java_util_Map$HA$HA', function (indices, nPolygons, bsPolygons, faceVertexMax, htColixes, colixes, polygonColixes) {
var isAll=(bsPolygons == null );
var i0=(isAll ? nPolygons - 1 : bsPolygons.nextSetBit$I(0));
for (var i=i0; i >= 0; i=(isAll ? i - 1 : bsPolygons.nextSetBit$I(i + 1))) {
if (polygonColixes == null ) {
this.output$S(htColixes.get$O(Short.valueOf$H(colixes[indices[i][0]])) + " " + htColixes.get$O(Short.valueOf$H(colixes[indices[i][1]])) + " " + htColixes.get$O(Short.valueOf$H(colixes[indices[i][2]])) + " -1\n" );
if (faceVertexMax == 4 && indices[i].length == 4 ) this.output$S(htColixes.get$O(Short.valueOf$H(colixes[indices[i][0]])) + " " + htColixes.get$O(Short.valueOf$H(colixes[indices[i][2]])) + " " + htColixes.get$O(Short.valueOf$H(colixes[indices[i][3]])) + " -1\n" );
} else {
this.output$S(htColixes.get$O(Short.valueOf$H(polygonColixes[i])) + "\n");
}}
});

Clazz.newMeth(C$, 'outputTriangle$javajs_util_T3$javajs_util_T3$javajs_util_T3$H', function (pt1, pt2, pt3, colix) {
this.output$S("Shape{geometry IndexedFaceSet{ ");
p$1.outputTriangleGeometry$javajs_util_T3$javajs_util_T3$javajs_util_T3$H.apply(this, [pt1, pt2, pt3, colix]);
this.output$S("}\n");
this.outputAppearance$H$Z(colix, false);
this.output$S("}\n");
});

Clazz.newMeth(C$, 'outputTriangleGeometry$javajs_util_T3$javajs_util_T3$javajs_util_T3$H', function (pt1, pt2, pt3, colix) {
if (this.oneFace == null ) {
this.oneFace=Clazz.array(Integer.TYPE, -2, [Clazz.array(Integer.TYPE, -1, [0, 1, 2])]);
this.threeVertices=Clazz.array($I$(2), -1, [this.tempP1, this.tempP2, this.tempP3]);
}this.threeVertices[0].setT$javajs_util_T3(pt1);
this.threeVertices[1].setT$javajs_util_T3(pt2);
this.threeVertices[2].setT$javajs_util_T3(pt3);
this.outputGeometry$javajs_util_T3A$javajs_util_T3A$HA$IAA$HA$I$I$javajs_util_BS$I$javajs_util_Lst$java_util_Map$javajs_util_P3(this.threeVertices, null, null, this.oneFace, null, 3, 1, null, 3, null, null, null);
}, p$1);

Clazz.newMeth(C$, 'outputTextPixel$javajs_util_P3$I', function (pt, argb) {
});

Clazz.newMeth(C$, 'plotText$I$I$I$H$S$org_jmol_util_Font', function (x, y, z, colix, text, font3d) {
this.pushMatrix$();
this.tempP3.set$F$F$F(x, y, this.fixScreenZ$I(z));
this.tm.unTransformPoint$javajs_util_T3$javajs_util_T3(this.tempP3, this.tempP1);
this.outputAttrPt$S$javajs_util_T3("translation", this.tempP1);
p$1.setFont$H$S$org_jmol_util_Font.apply(this, [colix, text, font3d]);
this.outputChildStart$();
if (this.fontChild.charAt$I(0) == "_") {
this.output$S("DEF " + this.fontChild + " Billboard{" );
this.outputAttr$S$F$F$F("axisOfRotation", 0, 0, 0);
this.outputChildStart$();
this.pushMatrix$();
this.outputChildShapeStart$();
this.output$S("Text{fontStyle ");
var fontstyle=this.getDef$S("F" + this.fontFace + this.fontStyle );
if (fontstyle.charAt$I(0) == "_") {
this.output$S("DEF " + fontstyle + " FontStyle{size " + new Float(this.fontSize).toString() + " family \"" + this.fontFace + "\" style \"" + this.fontStyle + "\"}" );
} else {
this.output$S(fontstyle);
}this.output$S(" string " + $I$(6).esc$S(text) + "}" );
this.outputAppearance$H$Z(colix, true);
this.outputChildShapeClose$();
this.popMatrix$();
this.outputChildClose$();
this.output$S("}");
} else {
this.output$S(this.fontChild);
}this.outputChildClose$();
this.popMatrix$();
});

Clazz.newMeth(C$, 'setFont$H$S$org_jmol_util_Font', function (colix, text, font3d) {
this.fontStyle=font3d.fontStyle.toUpperCase$();
this.fontFace=font3d.fontFace.toUpperCase$();
this.fontFace=(this.fontFace.equals$O("MONOSPACED") ? "TYPEWRITER" : this.fontFace.equals$O("SERIF") ? "SERIF" : "Arial");
this.fontSize=font3d.fontSize * 0.015;
this.fontChild=this.getDef$S("T" + colix + this.fontFace + this.fontStyle + new Float(this.fontSize).toString() + "_" + text );
}, p$1);

Clazz.newMeth(C$, 'getDef$S', function (key) {
return (this.useTable == null  ? "_" : this.useTable.getDef$S(key));
});
})();
;Clazz.setTVer('3.2.9-v1');//Created 2020-06-01 14:49:33 Java2ScriptVisitor version 3.2.9-v1 net.sf.j2s.core.jar version 3.2.9-v1
